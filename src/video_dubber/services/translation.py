"""Helpers for translating transcript segments to a target language."""

from __future__ import annotations

import json
import re
from collections.abc import Iterable
from pathlib import Path
from typing import Any

from ..models import TranscriptSegment
from ..utils import save_prompt
from .openai_client import OpenAIClient


class TranslationService:
    """Translate transcript segments using a GPT-4o chat model."""

    def __init__(self, client: OpenAIClient, model: str) -> None:
        self._client = client
        self._model = model

    async def translate_segments(
        self,
        segments: Iterable[TranscriptSegment],
        target_language: str | None = None,
        instruction: str | None = None,
        prompt_root: Path | None = None,
        force_instruction: bool = False,
    ) -> tuple[list[TranscriptSegment], str | None]:
        """Translate each segment text into the desired language.

        Returns the updated segments and an optional speech instruction string
        generated by GPT-4o for downstream TTS synthesis.
        """

        segment_list = list(segments)
        if not segment_list:
            return [], None

        target_language = (target_language or "").strip()
        instruction = (instruction or "").strip()
        if not target_language and not instruction:
            if not force_instruction:
                return segment_list, None
            # When no translation or rewrite guidance is provided but a speech instruction is
            # required, keep the text untouched while requesting a tone directive from GPT-4o.

        payload = {
            "segments": [
                {"index": index, "text": segment.text}
                for index, segment in enumerate(segment_list)
            ],
            "expect_speech_instruction": True,
        }
        if force_instruction and not target_language and not instruction:
            payload["preserve_text"] = True

        if target_language:
            payload["target_language"] = target_language
        if instruction:
            payload["instruction"] = instruction

        request_snapshot = {
            "model": self._model,
            "target_language": target_language or None,
            "instruction": instruction or None,
            "force_instruction": force_instruction or None,
            "payload": payload,
        }
        save_prompt(
            prompt_root,
            category="translation",
            name="segments",
            content=json.dumps(request_snapshot, indent=2, ensure_ascii=False),
            suffix="json",
        )

        response = await self._client.client.responses.create(
            model=self._model,
            input=[
                {
                    "role": "system",
                    "content": [
                        {
                            "type": "input_text",
                            "text": (
                                "You rewrite transcript segments. When 'target_language' is present you must translate "
                                "each segment into that language. When 'instruction' is provided, follow it closely "
                                "while keeping the meaning of each segment. Always preserve speaker intent and timing. "
                                "If neither 'target_language' nor 'instruction' is supplied but 'preserve_text' is true, "
                                "return the original text unchanged for each segment. "
                                "Return a JSON object with keys 'segments' and 'speech_instruction'. The 'segments' "
                                "value must be an array of objects with keys 'index' and 'translation', matching the "
                                "order of the provided segments without extra commentary. The 'speech_instruction' "
                                "value must be a short directive that captures tone, pacing, and style for text-to-speech."
                            ),
                        }
                    ],
                },
                {
                    "role": "user",
                    "content": [
                        {
                            "type": "input_text",
                            "text": json.dumps(payload, ensure_ascii=False),
                        }
                    ],
                },
            ],
            temperature=0.0,
        )

        translated, speech_instruction = self._parse_response(response)

        by_index = {
            item["index"]: item["translation"]
            for item in translated
            if "index" in item and "translation" in item
        }

        result: list[TranscriptSegment] = []
        for index, segment in enumerate(segment_list):
            translated_text = by_index.get(index, segment.text)
            result.append(
                TranscriptSegment(start=segment.start, end=segment.end, text=translated_text)
            )

        return result, speech_instruction

    def _parse_response(self, response: Any) -> tuple[list[dict[str, Any]], str | None]:
        """Extract and parse JSON output from the model response."""

        text = self._extract_text(response)
        if not text:
            return [], None

        text = text.strip()

        candidates = [text]
        if "```" in text:
            code_blocks = re.findall(r"```(?:json)?\s*(.+?)```", text, re.DOTALL)
            candidates.extend(code_blocks)

        for candidate in candidates:
            cleaned = candidate.strip()
            try:
                parsed = json.loads(cleaned)
                if isinstance(parsed, dict):
                    payload = parsed.get("segments")
                    instruction = parsed.get("speech_instruction")
                    segment_items: list[dict[str, Any]] = []
                    if isinstance(payload, list):
                        segment_items = [item for item in payload if isinstance(item, dict)]
                    speech_instruction = (
                        str(instruction).strip() if isinstance(instruction, str) else None
                    )
                    return segment_items, speech_instruction
                if isinstance(parsed, list):
                    return [item for item in parsed if isinstance(item, dict)], None
            except json.JSONDecodeError:
                continue

        return [], None

    def _extract_text(self, response: Any) -> str:
        """Flatten the response object into plain text."""

        if hasattr(response, "output_text") and response.output_text:
            return str(response.output_text)

        output = getattr(response, "output", None)
        if output:
            chunks: list[str] = []
            for message in output:
                content = getattr(message, "content", None)
                if not content:
                    continue
                for block in content:
                    text = getattr(block, "text", None)
                    if text:
                        chunks.append(str(text))
            if chunks:
                return "".join(chunks)

        choices = getattr(response, "choices", None)
        if choices:
            pieces: list[str] = []
            for choice in choices:
                message = getattr(choice, "message", None)
                if not message:
                    continue
                text = getattr(message, "content", None)
                if text:
                    pieces.append(str(text))
            if pieces:
                return "".join(pieces)

        if isinstance(response, dict):
            return str(response.get("output_text") or response)

        return ""
